# üì¶ API de Entregas ‚Äî Simula√ß√£o dos Correios

Este projeto √© um backend de API REST desenvolvido em Laravel que simula o funcionamento de um sistema de entregas semelhante ao dos Correios. A aplica√ß√£o permite gerenciar ag√™ncias, unidades, clientes, encomendas, servi√ßos, fretes e rastreamentos, fornecendo uma solu√ß√£o completa para opera√ß√µes log√≠sticas.

---

## üìã Sobre o Projeto

A API foi desenvolvida seguindo boas pr√°ticas de desenvolvimento de software, implementando padr√µes de projeto (Design Patterns) e princ√≠pios SOLID para garantir c√≥digo limpo, manuten√≠vel e escal√°vel. A arquitetura do sistema separa responsabilidades entre camadas (Controllers, Services, Repositories), utiliza CQRS para separa√ß√£o de comandos e consultas, implementa o padr√£o Strategy para c√°lculos de frete flex√≠veis e utiliza Factory para cria√ß√£o de objetos cliente.

### Funcionalidades Principais

- **Gest√£o de Clientes**: Cadastro e gerenciamento de clientes pessoa f√≠sica e jur√≠dica
- **Gest√£o de Encomendas**: Cria√ß√£o e acompanhamento de encomendas
- **C√°lculo de Fretes**: Sistema flex√≠vel com m√∫ltiplas estrat√©gias de c√°lculo
- **Rastreamento**: Acompanhamento em tempo real do status das encomendas
- **Gest√£o de Ag√™ncias e Unidades**: Organiza√ß√£o hier√°rquica da estrutura operacional
- **Autentica√ß√£o**: Sistema de autentica√ß√£o utilizando Laravel Sanctum

---

## üóÇ Modelagem e Decis√µes de Projeto

A modelagem do banco de dados foi desenvolvida para representar fielmente o fluxo de trabalho dos Correios, desde a postagem de um pacote at√© sua entrega final.

### Estrutura de Entidades e Relacionamentos

- **Ag√™ncia e Unidades**
  - Cada ag√™ncia pode ter diversas unidades operacionais.
  - As unidades executam etapas como postagem, triagem e entrega.

- **Funcion√°rios**
  - Associados a uma unidade, respons√°veis pelo atendimento e processamento de encomendas.

- **Clientes**
  - Diferencia clientes pessoa f√≠sica (`cliente_pessoa`) e pessoa jur√≠dica (`cliente_empresa`), mantendo dados centrais na tabela `cliente` para padroniza√ß√£o.

- **Encomendas**
  - Cont√™m peso, data de postagem e est√£o vinculadas a remetente, destinat√°rio, servi√ßo.

- **Servi√ßos**
  - Representam modalidades de envio (PAC, Sedex etc.) com pre√ßo base e prazo.
  - Suportam diferentes tipos de c√°lculo de frete (`tipo_calculo`).

- **Fretes**
  - Associados a uma encomenda, guardam informa√ß√µes de custo e permitem simular c√°lculos de envio.

- **Rastreamentos**
  - Registram o hist√≥rico de status da encomenda, possibilitando o acompanhamento em tempo real.

---

## üéØ Como a Modelagem Atende ao Tema

1. **Simula√ß√£o realista**: Inclui entidades e relacionamentos que refletem o funcionamento dos Correios.
2. **Flexibilidade**: Suporte a m√∫ltiplos tipos de clientes e servi√ßos.
3. **Escalabilidade**: Estrutura pronta para integra√ß√£o futura com APIs reais ou novos m√≥dulos de rastreamento.
4. **Organiza√ß√£o**: Separa√ß√£o l√≥gica entre entidades e relacionamentos para facilitar manuten√ß√£o e evolu√ß√£o do projeto.

---

## üìå Diagrama ER

![Diagrama ER](docs/api_entrega_1.png)

---

## üöÄ Tecnologias Utilizadas

- **PHP** + **Laravel** ‚Äî Backend e rotas
- **MySQL** ‚Äî Banco de dados relacional
- **Eloquent** ‚Äî ORM para manipula√ß√£o de dados
- **Laravel Sanctum** ‚Äî Autentica√ß√£o de API

---

## üèó Arquitetura e Padr√µes de Projeto

### Princ√≠pios SOLID Aplicados

O projeto aplica os cinco princ√≠pios SOLID em diferentes partes do c√≥digo:

#### 1. Single Responsibility Principle (SRP) - Princ√≠pio da Responsabilidade √önica

**Localiza√ß√£o:**
- **Controllers** (`app/Http/Controllers/`): Respons√°veis apenas por receber requisi√ß√µes HTTP e retornar respostas
  - Exemplo: `ClienteController` - gerencia apenas rotas e valida√ß√µes HTTP
  - Exemplo: `RastreamentoController` - coordena comandos e queries de rastreamento
  
- **Services** (`app/Services/`): Cont√™m a l√≥gica de neg√≥cio espec√≠fica
  - Exemplo: `ClientService` - gerencia opera√ß√µes de neg√≥cio relacionadas a clientes
  - Exemplo: `FreteService` - gerencia c√°lculos de frete
  
- **Repositories** (`app/Repositories/`): Respons√°veis exclusivamente pelo acesso a dados
  - Exemplo: `ClientRepository` - encapsula todas as opera√ß√µes de persist√™ncia de clientes
  
- **Commands e Queries** (`app/CQRS/`): Separadas por responsabilidade √∫nica
  - Commands: `UpdateRastreamentoCommand` e `UpdateRastreamentoHandler` - apenas modifica√ß√µes
  - Queries: `GetAllRastreamentosQuery`, `GetRastreamentoByIdQuery`, etc. - apenas leitura

#### 2. Open/Closed Principle (OCP) - Princ√≠pio Aberto/Fechado

**Localiza√ß√£o:**
- **Strategy Pattern** (`app/Strategies/FreteCalculator/`): O sistema permite adicionar novas estrat√©gias de c√°lculo de frete sem modificar c√≥digo existente
  - `FreteCalculatorInterface` define o contrato
  - Estrat√©gias implementadas: `PorPesoStrategy`, `PorFaixaStrategy`, `PrecoFixoStrategy`, `PorDistanciaStrategy`
  - `FreteCalculatorContext` e `FreteService` funcionam com qualquer implementa√ß√£o da interface, sem necessidade de altera√ß√£o ao adicionar novas estrat√©gias

**Exemplo:**
```php
// app/Services/FreteService.php
// O c√≥digo est√° fechado para modifica√ß√£o, mas aberto para extens√£o
$strategy = match ($tipoCalculo) {
    'por_peso' => new PorPesoStrategy(),
    'por_faixa' => new PorFaixaStrategy(),
    // Novas estrat√©gias podem ser adicionadas sem alterar este c√≥digo
};
```

#### 3. Liskov Substitution Principle (LSP) - Princ√≠pio da Substitui√ß√£o de Liskov

**Localiza√ß√£o:**
- **Strategy Pattern** (`app/Strategies/FreteCalculator/`): Todas as estrat√©gias implementam `FreteCalculatorInterface` e s√£o intercambi√°veis
  - Qualquer implementa√ß√£o pode substituir outra sem quebrar o comportamento do `FreteCalculatorContext`
  - Exemplo: `PorPesoStrategy`, `PrecoFixoStrategy`, etc. podem ser usadas indistintamente

#### 4. Interface Segregation Principle (ISP) - Princ√≠pio da Segrega√ß√£o de Interface

**Localiza√ß√£o:**
- **Contracts** (`app/Contracts/ClientRepositoryInterface.php`): Interface cont√©m apenas os m√©todos necess√°rios para opera√ß√µes de cliente
  - M√©todos espec√≠ficos: `createClientPessoa`, `createClientEmpresa`, `update`, `find`, `destroy`
  - N√£o for√ßa implementa√ß√µes a incluir m√©todos desnecess√°rios

#### 5. Dependency Inversion Principle (DIP) - Princ√≠pio da Invers√£o de Depend√™ncia

**Localiza√ß√£o:**
- **Repository Pattern** (`app/Contracts/ClientRepositoryInterface.php` e `app/Repositories/ClientRepository.php`):
  - `ClientService` depende da abstra√ß√£o `ClientRepositoryInterface`, n√£o da implementa√ß√£o concreta
  - A implementa√ß√£o concreta `ClientRepository` √© injetada via Service Provider
  
- **Service Provider** (`app/Providers/RepositoryServiceProvider.php`):
  - Realiza o binding da interface com a implementa√ß√£o concreta usando inje√ß√£o de depend√™ncia do Laravel
  
- **Factory Pattern** (`app/Factories/ClientFactory.php`):
  - `ClientFactory` recebe `ClientRepositoryInterface` no construtor, dependendo da abstra√ß√£o, n√£o da implementa√ß√£o

- **Strategy Pattern**:
  - `FreteCalculatorContext` depende da abstra√ß√£o `FreteCalculatorInterface`, n√£o de implementa√ß√µes concretas
  - `FreteService` utiliza a interface para trabalhar com qualquer estrat√©gia

**Exemplo:**
```php
// app/Factories/ClientFactory.php
public function __construct(ClientRepositoryInterface $repository)
{
    $this->repository = $repository;
}
```

---

### Padr√£o CQRS (Command Query Responsibility Segregation)

**Localiza√ß√£o:** `app/CQRS/`

O padr√£o CQRS separa as opera√ß√µes de leitura (Queries) das opera√ß√µes de escrita (Commands), proporcionando melhor organiza√ß√£o e possibilidade de otimiza√ß√£o independente.

#### Commands (Comandos - Modifica√ß√µes)
- **Localiza√ß√£o:** `app/CQRS/Commands/Rastreamento/`
  - `UpdateRastreamentoCommand.php`: Objeto que representa o comando de atualiza√ß√£o
  - `UpdateRastreamentoHandler.php`: Handler que processa o comando de atualiza√ß√£o de rastreamento
  
**Uso:** `RastreamentoController::update()` cria e executa o comando atrav√©s do handler

#### Queries (Consultas - Leitura)
- **Localiza√ß√£o:** `app/CQRS/Queries/Rastreamento/`
  - `GetAllRastreamentosQuery.php`: Query para listar todos os rastreamentos
  - `GetRastreamentoByIdQuery.php`: Query para buscar rastreamento por ID
  - `GetRastreamentosByEncomendaQuery.php`: Query para buscar rastreamentos por encomenda
  - `RastreamentoQueryHandler.php`: Handler que processa todas as queries de rastreamento
  
**Uso:** `RastreamentoController` utiliza as queries atrav√©s do `RastreamentoQueryHandler` nos m√©todos `index()`, `show()` e `showRastreamentosRelatedToEncomenda()`

**Benef√≠cios:**
- Separa√ß√£o clara entre leitura e escrita
- Facilita testes unit√°rios
- Permite otimiza√ß√£o independente de queries e commands
- Melhora a manutenibilidade do c√≥digo

---

### Padr√£o Strategy

**Localiza√ß√£o:** `app/Strategies/FreteCalculator/`

O padr√£o Strategy permite que o algoritmo de c√°lculo de frete seja selecionado em tempo de execu√ß√£o, baseado no tipo de c√°lculo configurado no servi√ßo.

#### Componentes:

1. **Interface:** `FreteCalculatorInterface.php`
   - Define o contrato que todas as estrat√©gias devem implementar
   - M√©todo: `calcular(Encomenda $encomenda): float`

2. **Estrat√©gias Concretas:**
   - `PorPesoStrategy.php`: Calcula frete baseado no peso da encomenda
   - `PorFaixaStrategy.php`: Calcula frete baseado em faixas de peso/dist√¢ncia
   - `PrecoFixoStrategy.php`: Retorna um pre√ßo fixo do servi√ßo
   - `PorDistanciaStrategy.php`: Calcula frete baseado na dist√¢ncia

3. **Context:** `FreteCalculatorContext.php`
   - Classe que mant√©m refer√™ncia √† estrat√©gia atual
   - M√©todo `setStrategy()` para definir a estrat√©gia
   - M√©todo `executar()` para executar o c√°lculo usando a estrat√©gia configurada

4. **Service:** `app/Services/FreteService.php`
   - Utiliza o contexto e seleciona a estrat√©gia apropriada baseada no `tipo_calculo` do servi√ßo
   - M√©todos: `calcularFrete()` e `calcularFreteArredondado()`

**Fluxo de Uso:**
1. `FreteService` identifica o `tipo_calculo` do servi√ßo da encomenda
2. Instancia a estrat√©gia correspondente
3. Define a estrat√©gia no contexto
4. Executa o c√°lculo

**Benef√≠cios:**
- Facilita adicionar novas estrat√©gias de c√°lculo sem modificar c√≥digo existente
- C√≥digo mais limpo e organizado
- Respeita o princ√≠pio Open/Closed

---

### Padr√£o Factory

**Localiza√ß√£o:** `app/Factories/ClientFactory.php`

O padr√£o Factory encapsula a l√≥gica de cria√ß√£o de objetos cliente, centralizando a decis√£o de qual tipo de cliente (Pessoa ou Empresa) deve ser criado.

#### Implementa√ß√£o:

**Factory:** `ClientFactory.php`
- Recebe `ClientRepositoryInterface` via inje√ß√£o de depend√™ncia (DIP)
- M√©todo `create(array $data): Cliente`
- Decide qual tipo de cliente criar baseado no campo `tipo` dos dados recebidos
- Delega a cria√ß√£o espec√≠fica para o repository apropriado

**Uso:**
- `ClientService::createClient()` utiliza a factory para criar clientes
- A factory abstrai a complexidade de cria√ß√£o, permitindo que o service n√£o precise conhecer os detalhes de implementa√ß√£o

**Fluxo:**
1. `ClienteController::store()` recebe requisi√ß√£o
2. `ClientService::createClient()` chama `ClientFactory::create()`
3. Factory identifica o tipo e chama o m√©todo apropriado do repository
4. Repository cria o cliente no banco de dados

**Benef√≠cios:**
- Centraliza a l√≥gica de cria√ß√£o
- Facilita adicionar novos tipos de cliente no futuro
- Reduz acoplamento entre service e repository
- Melhora a testabilidade

---

## üìÅ Estrutura de Diret√≥rios

```
app/
‚îú‚îÄ‚îÄ Contracts/              # Interfaces (ISP, DIP)
‚îÇ   ‚îî‚îÄ‚îÄ ClientRepositoryInterface.php
‚îú‚îÄ‚îÄ CQRS/                   # Padr√£o CQRS
‚îÇ   ‚îú‚îÄ‚îÄ Commands/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Rastreamento/
‚îÇ   ‚îî‚îÄ‚îÄ Queries/
‚îÇ       ‚îî‚îÄ‚îÄ Rastreamento/
‚îú‚îÄ‚îÄ Factories/              # Padr√£o Factory
‚îÇ   ‚îî‚îÄ‚îÄ ClientFactory.php
‚îú‚îÄ‚îÄ Http/
‚îÇ   ‚îú‚îÄ‚îÄ Controllers/        # SRP - Apenas HTTP
‚îÇ   ‚îú‚îÄ‚îÄ Middleware/
‚îÇ   ‚îî‚îÄ‚îÄ Requests/
‚îú‚îÄ‚îÄ Models/
‚îú‚îÄ‚îÄ Providers/              # DIP - Inje√ß√£o de depend√™ncia
‚îÇ   ‚îî‚îÄ‚îÄ RepositoryServiceProvider.php
‚îú‚îÄ‚îÄ Repositories/           # SRP - Acesso a dados
‚îÇ   ‚îî‚îÄ‚îÄ ClientRepository.php
‚îú‚îÄ‚îÄ Services/               # SRP - L√≥gica de neg√≥cio
‚îÇ   ‚îú‚îÄ‚îÄ ClientService.php
‚îÇ   ‚îî‚îÄ‚îÄ FreteService.php
‚îî‚îÄ‚îÄ Strategies/             # Padr√£o Strategy (OCP, LSP)
    ‚îî‚îÄ‚îÄ FreteCalculator/
```

---

## üîß Configura√ß√£o e Instala√ß√£o

### Pr√©-requisitos

- PHP >= 8.1
- Composer
- MySQL >= 5.7
- Node.js e NPM (para assets)

### Instala√ß√£o

1. Clone o reposit√≥rio
2. Instale as depend√™ncias:
   ```bash
   composer install
   npm install
   ```
3. Configure o arquivo `.env` com suas credenciais de banco de dados
4. Execute as migra√ß√µes:
   ```bash
   php artisan migrate
   ```
5. (Opcional) Execute os seeders:
   ```bash
   php artisan db:seed
   ```
6. Inicie o servidor:
   ```bash
   php artisan serve
   ```

---

## üìù API Endpoints

A documenta√ß√£o completa da API pode ser encontrada atrav√©s das rotas definidas em `routes/api.php`.

Principais endpoints:
- `/api/clientes` - CRUD de clientes
- `/api/encomendas` - CRUD de encomendas
- `/api/fretes` - C√°lculo e gest√£o de fretes
- `/api/rastreamentos` - Consulta e atualiza√ß√£o de rastreamentos
- `/api/auth` - Autentica√ß√£o

---

## üß™ Testes

O projeto inclui testes unit√°rios e de integra√ß√£o. Execute com:

```bash
php artisan test
```

---

## üìÑ Licen√ßa

Este projeto foi desenvolvido para fins educacionais.

---

## üë• Contribui√ß√£o

Este √© um projeto acad√™mico desenvolvido para demonstrar a aplica√ß√£o de princ√≠pios SOLID e padr√µes de projeto em uma API Laravel.
